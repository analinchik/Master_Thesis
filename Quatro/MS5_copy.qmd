---
title: "MS5"
format: 
  html:
    embed-resources: true
    theme: flatly
    toc: true
    toc-depth: 3
    toc-expand: 3
    toc-title: Contents
    smooth-scroll: true
editor: visual
params:
  organism: human
---

# Loading packages

```{r}
#| echo: false
#| include: false
#| warning: false

library(dplyr)
library(ggplot2)
library(tidyr)
library(readxl)
library(kableExtra)
library(ggpubr)
library(plotly)
library(car)  # for ANOVA
library(multcomp)  # for post-hoc tests
library(rcompanion)  # for wtd.boxplot.stats
#BiocManager::install("idpr")
#library(idpr)
```

# Loading dataframes

```{r}
#| echo: false
#| include: false
human_df <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/Human-separateProjects.csv", header = T)

# This is just a filtered by Post-translational
human_ptms <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/human_ptms.tsv", header = T, sep = '\t')
human_ptms_hl <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/human_ptms_hl.tsv", header = T, sep = '\t')


human_ptms_expanded <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/human_ptms_expanded.tsv", header = T, sep = '\t')
human_ptms_expanded_hl <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/human_ptms_expanded_hl.tsv", header = T, sep = '\t')
human_ptms_expanded_length <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/human_ptms_expanded_length.tsv", header = T, sep = '\t')
human_ptms_expanded_hl_lengths <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/human_ptms_expanded_hl_lengths.tsv", header = T, sep = '\t')

hl <- read.csv(file = '/Users/anastasialinchik/Desktop/Thesis/DATA/generated/hl.tsv', header = T, sep = '\t')
cell_types_hl <- read.csv(file = '/Users/anastasialinchik/Desktop/Thesis/DATA/generated/long_proteins_hl_cell_types.tsv', header = T, sep = '\t')
long_proteins_hl <- read.csv(file = '/Users/anastasialinchik/Desktop/Thesis/DATA/generated/long_proteins_hl_cell_types.tsv', header = T, sep = '\t')
ageing_proteins <- read_excel( '/Users/anastasialinchik/Desktop/Thesis/DATA/Age-correlated protein.xlsx')
oxPTMs <- read.table(file = '/Users/anastasialinchik/Desktop/Thesis/Master_thesis/oxPTMs_unimod.txt', header = T)
```

# Normalisation

The PSM (protein-spectrum match) counts were normalised using the number of raw files that were analysed for each project. The number of raw files per project can be found on PRIDE. For some projects, it wasn't possible to analyse all of the files therefore the number of raw files was smaller than expected.

Normalisation: \`norm_counts = PSM_counts/raw_files_counts\`

# Hypotheses

## PTMs and protein half-lives

A protein half-life is the time it takes for the concentration of a radioactively protein to decrease by half. Protein half-lives can be used as estimates of residence time of proteins in the cell.

Proteins that reside longer in the cell may be more susceptible to oxidative damage.

Protein half-lives were obtained from: [paper1](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5975921/), [paper2](https://www-science-org.kuleuven.e-bronnen.be/doi/10.1126/science.1199784#appendix).

Another paper with protein half-lives: [paper3](https://www.nature.com/articles/s41467-018-03106-1#Sec25).

It is assumed that each protein only has one modification. The proteins with no modifications are not identified.

### Distribution of protein half-lives

Approach:

-   Get a list of PTMs that correlate with ageing

-   Test whether the abundance of PTMs changes between the long-lived proteins and the normal proteins

The distribution of protein half-lives in the dataset can be seen here:

```{r}
#| echo: false
ggplot(human_ptms_expanded_hl, aes(x = mean_hl_hours, weight = norm_counts)) +
  geom_histogram(bins = 50, fill = "#5DB7B1") + 
  labs(title = 'Distribution of half-lives among proteins with PTMs', x = 'Mean half-lives (hours)', y = 'Counts') +
  theme_classic()
```

The above distribution shows that the mean mean half-life of a protein in this dataset is around 8, which is within the expected range when compared to values found in [literature](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3788602/).

A boxplot was plotted in order to better visualise the proteins with exceptionally high half-lives. The boxplot does not use normalised counts due to the high number of data points. It can be seen that there are outliers in the boxplot, most of which have a high mean half-life. In total there are 84083 outliers.

```{r}
ggplot(human_ptms_hl, aes(y = mean_hl_hours)) +
  geom_boxplot() +
  theme_classic()
```

-   The distribution of the half-lives of the outliers is plotted below. Here, normalised counts are used.

```{r}
#| echo: false

# here the weights are not taken into account when calculating outliers

# Calculate boxplot statistics
boxplot_stats <- boxplot.stats(human_ptms_expanded_hl$mean_hl_hours)

# Calculate IQR
IQR <- boxplot_stats$stats[4] - boxplot_stats$stats[2]

# Define lower and upper bounds for outliers
lower_bound <- boxplot_stats$stats[2] - 1.5 * IQR
upper_bound <- boxplot_stats$stats[4] + 1.5 * IQR

# Filter outliers
outliers_df <- human_ptms_expanded_hl %>%
  filter(mean_hl_hours < lower_bound | mean_hl_hours > upper_bound)

ggplot(outliers_df, aes(y = mean_hl_hours, weight = norm_counts)) +
  geom_boxplot(fill = "#5DB7B1") + 
  labs(title = 'Distribution of half-lives among outlier proteins', y = 'Mean half-lives (hours)') +
  theme_classic()
```

Though the mean half-life of these proteins is higher than the mean half-life of the whole dataset, one of the outlier proteins can be classified as long-lived proteins. Proteins can be classified as long-lived when their mean half-life exceeds 48 hours ([ref](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC5500981/#:~:text=Many%20of%20your%20body's%20proteins,%2Dlived%20protein%20(LLP).)), though this is an arbitrary definition.

Violin plot:

```{r}
#| echo: false
#| eval: false

human_ptms_expanded_hl_top5 <- human_ptms_expanded_hl %>% filter(ptm_name %in% c('[35]Oxidation', '[34]Methyl', '[40]Sulfo', '[21]Phospho', '[7]Deamidated'))

ggplot(human_ptms_expanded_hl_top5, aes(x = ptm_name, y = mean_hl_hours, weight = norm_counts)) +
  geom_violin(bw=0.5, fill = '#73BFB8') +
  geom_boxplot(width=0.3) + 
  labs(x = 'PTM name', y = 'Half-life (hours)', title = 'Distribution of protein half-lives separated by PTMs') +
  stat_summary(fun=mean, geom="point", shape=19, size=2.5, colour = '#EA7317') +
  theme_linedraw(base_size = 12)
```

Oxidation:

```{r}
human_ptms_expanded_hl_top5 <- human_ptms_expanded_hl %>% filter(ptm_name %in% c('[35]Oxidation'))

ggplot(human_ptms_expanded_hl_top5, aes(x = ptm_name, y = mean_hl_hours, weight = norm_counts)) +
  geom_violin(bw=0.5, fill = '#73BFB8') +
  geom_boxplot(width=0.3) + 
  labs(x = 'PTM name', y = 'Half-life (hours)', title = 'Distribution of protein half-lives separated by PTMs') +
  stat_summary(fun=mean, geom="point", shape=19, size=2.5, colour = '#EA7317') +
  theme_linedraw(base_size = 12)
```

Violin plot for oxPTMs:

```{r}

human_ptms_oxPTMs <- human_ptms_hl %>% filter(unimod_id %in% oxPTMs$ID)

ggplot(human_ptms_oxPTMs, aes(x = '', y = mean_hl_hours, weight = norm_counts)) +
  geom_violin(bw=0.5, fill = '#73BFB8') +
  labs(x = 'oxPTMs', y = 'Half-life (hours)', title = 'Distribution of protein half-lives separated by PTMs') +
  theme_linedraw(base_size = 12)
```

-   What are the these proteins in the small peak?

Above we can see that the PTM type does not affect the mean half-life of the protein.

ANOVA:

The group sizes are so large (there are 1 million entries between the 5 groups) that even a small difference between the groups will result in significant p-values.

```{r}
#| echo: false
#| eval: false

human_ptms_expanded_hl_top5$ptm_name <- factor(human_ptms_expanded_hl_top5$ptm_name)
# ANOVA
anova_result <- aov(mean_hl_hours ~ ptm_name, data = human_ptms_expanded_hl_top5)
summary(anova_result)

# Post-hoc tests
posthoc_tests <- glht(anova_result, linfct = mcp(ptm_name = "Tukey"))
summary(posthoc_tests)

# Checking ANOVA assumptions

# 1. Independence: Assumed to be met during experimental design.

# 2. Normality of residuals
residuals <- residuals(anova_result)
hist(residuals, main = "Histogram of Residuals")
qqnorm(residuals)
qqline(residuals)

# Shapiro-Wilk test for normality
shapiro.test(residuals)

# 3. Homogeneity of variances
plot(anova_result, 1)  # 1 corresponds to residuals vs fitted values
# Levene's test for homogeneity of variances
leveneTest(anova_result)

# 4. Linearity: Assumed to be met during model specification.
```

**Hypothesis**: proteins with higher mean half-lives remain in the cell for longer, therefore they are more susceptible to oxidative damage and will accumulate more oxPTMs.

Approach:

-   Count the total number of oxPTMs on each protein (using normalised counts)

-   Plot the mean half-life of the proteins vs their total oxPTMs count

```{r}
#| echo: false

oxPTMs_hl <- human_ptms_expanded_hl %>% 
  inner_join(oxPTMs, by = join_by(unimod_id == ID)) %>%
  group_by(LeadProt) %>%
  summarise(mean_hl_hours, sum_oxPTMs = sum(norm_counts)) %>%
  distinct()

ggplot(oxPTMs_hl, aes(x = mean_hl_hours, y = sum_oxPTMs)) +
  geom_point() +
  theme_classic()
```

### Phosphorylation

```{r}
human_ptms_expanded_hl_phospho <- human_ptms_expanded_hl %>% filter(ptm_name == '[21]Phospho')
ggplot(human_ptms_expanded_hl_phospho, aes(x = mean_hl_hours)) +
  geom_histogram(bins = 50) + 
  labs(title = 'Distribution of half lives of phosphorylated proteins', x = 'Mean half-life (hours)', y = 'Counts')+
  theme_linedraw()
```

### Oxidation

```{r}
human_ptms_expanded_hl_oxi <- human_ptms_expanded_hl %>% filter(ptm_name == '[35]Oxidation')
ggplot(human_ptms_expanded_hl_oxi, aes(x = mean_hl_hours)) +
  geom_histogram(bins = 50) +
  labs(title = 'Distribution of half-lives of oxidised proteins', x = 'Mean half-life (hours)', y = 'Counts')+
  theme_linedraw()
```

### Most modified PTMs proteins?

```{r}
ggplot(human_ptms_expanded_hl, aes(x = ptm_res)) +
  geom_histogram(stat = 'count') +
  labs(title = 'PTM counts for each residue', x = 'Residue', y = 'Counts') +
  theme_linedraw()
```

## PTMs and protein lengths

Protein lengths were found on UniProt.

The assumption is made that each protein can only have 1 PTM.

```{r}
#| echo: false

ggplot(human_ptms_expanded_length, aes(x = Length, weight = norm_counts)) +
  geom_histogram(fill = '#73BFB8', bins = 50) +
  labs(title = 'Distribution of protein lengths', x = 'Length (in amino acids)', y = 'Normalised counts') +
  theme_linedraw(base_size = 16)
```

Proteins that are longer than 20,000 amino acids.

```{r}
#| echo: false
long_proteins <- human_ptms_expanded_length %>% filter(Length > 20000) %>% dplyr::select(Uniprot_entry_name, Length) %>% distinct()

kable(long_proteins)
```

```{r}
#| echo: false
#| warning: false
ggplot(human_ptms_expanded_length, aes(x = Length)) +
  geom_histogram(fill = '#73BFB8', bins = 50) +
  labs(title = 'Distribution of protein lengths with less than 10,000 amino acids', x = 'Length (in amino acids)', y = 'Counts') +
  scale_x_continuous(limits=c(0, 10000))+
  theme_linedraw(base_size = 13)
```

```{r}
human_ptms_expanded_length %>% 
  group_by(LeadProt) %>%
  mutate(PTMs_per_protein = sum(norm_counts)) %>%
  dplyr::select(LeadProt, Length, PTMs_per_protein) %>% distinct() %>%
  ggplot(aes(x = Length, y = PTMs_per_protein)) +
  geom_point() + 
  labs(title = 'Number of PTMs in function of protein length', x = 'Protein length (amino acids)', y = 'Number of PTMs (normalised)') +
  theme_linedraw()
```

```{r}
human_ptms_expanded_length %>% 
  group_by(LeadProt) %>%
  mutate(PTMs_per_protein = sum(norm_counts)) %>%
  dplyr::select(LeadProt, Length, PTMs_per_protein) %>% distinct() %>% 
  filter(Length < 10000) %>%
  ggplot(aes(x = Length, y = PTMs_per_protein)) +
  geom_point() +
  labs(title = 'Number of PTMs in function of protein length (zoomed in)', x = 'Protein length (amino acids)', y = 'Number of PTMs (normalised)') +
  theme_linedraw()
```

## PTMs and melting temperatures

```{r}
library(tidyr)
mt <- read_xlsx(path = '/Users/anastasialinchik/Desktop/Thesis/DATA/MeltingTemperatures.xlsx', sheet = 5,  col_names = T)

mt <- separate_rows(mt, Protein_ID, sep = ";")
```

```{r}
ptms_mt <- inner_join(mt, human_ptms_expanded_hl_lengths, by = join_by(Protein_ID == LeadProt))
ptms_mt <- ptms_mt %>% group_by(Protein_ID) %>%
  mutate(counts = n()) %>% 
  select(Protein_ID, counts, 'Tm Protein') %>%
  distinct()
names(ptms_mt) <- c('Protein_ID', 'counts', 'Tm')
```

```{r}
ggplot(ptms_mt, aes(x = Tm)) +
  geom_histogram(fill = '#73BFB8') +
  labs(x = 'Melting temperature', y = 'Counts') +
  theme_linedraw(base_size = 16)
```

```{r}
ggplot(ptms_mt, aes(x = Tm, y = counts)) +
  geom_point() +
  theme_linedraw(base_size = 16)
```

```{r}
human_ptms_grouped <- human_ptms %>%
  group_by(ptm_res) %>%
  summarize(PTMs = paste(unique(ptm_name), collapse = "; "))

kable(human_ptms_grouped, caption = "Summary of PTMs by PTM Residue")

table <- kable(human_ptms_grouped, 
      caption = "Summary of PTMs by PTM Residue",
      align = "l",              # Align all columns to the left
      col.names = c("PTM Residue", "Post-translational modification"),  # Specify column names
      format = "html",          # Format the table as HTML
      escape = FALSE,           # Allow HTML formatting
      table.attr = "style='width:50%; margin-left:auto; margin-right:auto;'", # Center the table and set width
      row.names = FALSE,        # Do not display row names
      bold.headers = TRUE      # Make headers bold
)

save_kable(table, file = "human_ptms_table.html")

table_png <- as_image(table)

# Save the image as PNG
png_file <- "human_ptms_table.png"
ggsave(png_file, table_png)

human_ptms_grouped %>%
  kbl(caption = "Recreating booktabs style table") %>%
  kable_classic(full_width = F, html_font = "Cambria")


kable(human_ptms_grouped, "latex") %>%
  kable_styling(latex_options = "striped") %>%
  save_kable("inst/test.png")

human_ptms_grouped %>%
  kbl() %>%
  kable_styling() %>%
  save_kable("test.png")

human_ptms_grouped %>%
  kbl() %>%
  kable_paper("hover", full_width = F) %>%
  save_kable("test.png")

kable(human_ptms_grouped, booktabs = T) %>%
  kable_styling(latex_options = c("striped", "scale_down")) %>%
  as_image(width = 8)
```

What is the difference between the means of the oxidative and non-oxidative modifications?

```{r}
oxPTMs <- read.table(file = '/Users/anastasialinchik/Desktop/Thesis/Master_thesis/oxPTMs_unimod.txt', header = T)

human_ptms$unimod_id <- gsub("\\[|\\].*", "", human_ptms$ptm_name)
human_ptms$unimod_id <- as.numeric(human_ptms$unimod_id)
summary(human_ptms)


human_ptms_oxi <- inner_join(human_ptms, oxPTMs, by = join_by(unimod_id == ID))
human_ptms_non_oxi <- anti_join(human_ptms, oxPTMs, by = join_by(unimod_id == ID))

```

```{r}
human_ptms_oxi$modification <- paste(human_ptms_oxi$ptm_name, human_ptms_oxi$ptm_res, sep = "_")

human_ptms_oxi <- human_ptms_oxi %>% 
  group_by(modification) %>% 
  summarise(mean = mean(total_psms))

ggplot(human_ptms_oxi, aes(x = mean)) +
  geom_histogram(aes(y=..density..))
```

```{r}
human_ptms_non_oxi$modification <- paste(human_ptms_non_oxi$ptm_name, human_ptms_non_oxi$ptm_res, sep = "_")

human_ptms_non_oxi <- human_ptms_non_oxi %>% 
  group_by(modification) %>% 
  summarise(mean = mean(total_psms))

ggplot(human_ptms_non_oxi, aes(x = mean)) +
  geom_histogram(aes(y=..density..))
```

Need to test ANOVA.

## Do proteins associated with ageing get modified more?

-   [This study](AgeAnnoMO:%20a%20knowledgebase%20of%20multi-omics%20annotation%20for%20animal%20aging) found a list of proteins that are associated with ageing. The mean number of modifications of these proteins will be compared to the mean number of modification of the proteins that are left in the dataset after excluding the ones associated with ageing.

-   Oxidative stress is a common phenomenon that occurs during the ageing process. This leads to oxidative damage of proteins, for example, through post-translational modifications.

-   No specific PTMs were selected here. All of the PTMs were used for the comparison.

-   The number of modifications that occur on proteins are compared between those that associated with ageing and the remaining ones.

-   Modification counts were normalised using the number of the proteins present in each group. eg there are 1052 ageing proteins that were present in the dataset. The counts of each modification was divided by this number.

-   A modification is characterised by the UNIMOD accession number and the residue. The location is not taken into account here. (modification = ptm_name + ptm_res)

Looking at the modifications in proteins related to ageing and those that are not related to ageing.

```{r}
# Filter for the human proteins
ageing_proteins <- ageing_proteins %>% filter(Animal == 'Human')

ageing_proteins_ids <- ageing_proteins %>% select('Uniprot entry') %>% distinct()

write.table(ageing_proteins_ids, file = '/Users/anastasialinchik/Desktop/Thesis/DATA/ageing_proteins_ids.tsv',sep = '\t', quote = F, row.names = F)

ageing_abundance <- inner_join(human_ptms, ageing_proteins_ids, by = join_by(LeadProt == 'Uniprot entry'))

ageing_abundance$modification <- paste(ageing_abundance$ptm_name, ageing_abundance$ptm_res, sep = "_")

ageing_abundance_sum <- ageing_abundance %>% 
  group_by(modification) %>% 
  summarise(mean = mean(total_counts)/1052)

ageing_abundance_sum$group <- 'ageing'
# now look at all of the proteins that are not included in the ageing related proteins list.

complementary_data <- anti_join(human_ptms, ageing_proteins_ids, by = join_by(LeadProt == 'Uniprot entry'))

complementary_data$modification <- paste(complementary_data$ptm_name, complementary_data$ptm_res, sep = "_")
complementary_data %>% distinct(LeadProt) %>% dim()

complementary_data_sum <- complementary_data %>% 
  group_by(modification) %>% 
  summarise(mean = mean(total_counts)/17877)

complementary_data_sum$group <- 'non-ageing' 

complete <- rbind(complementary_data_sum, ageing_abundance_sum)

# Outliers are excluded
ggplot(complete, aes(x = group, y = mean)) +
  geom_boxplot(outliers = F)
```

Checking assumptions before performing a parametric test.

```{r}
with(complete, shapiro.test(mean[group == "ageing"]))
```

```{r}
with(complete, shapiro.test(mean[group == "non-ageing"]))
```

Visualising the distribution of the modification counts.

```{r}
complete %>% filter(group == 'ageing') %>%
  ggplot( aes(x = mean)) +
  geom_histogram() +
  labs(title = 'Distribution of the modification counts in ageing proteins', x = 'Normalised modification count')
```

```{r}
complete %>% filter(group == 'non-ageing') %>%
  ggplot(aes(x = mean)) +
  geom_histogram() +
  labs(title = 'Distribution of the modification counts in non-ageing proteins', x = 'Normalised modification count')
```

```{r}
res.ftest <- var.test(mean ~ group, data = complete)
res.ftest
```

```{r}
# Compute t-test
res <- t.test(mean ~ group, data = complete, var.equal = TRUE)
res
```

## Conclusion

There is a significant difference between the number of modifications in ageing proteins and in non-ageing proteins.

-   Do the modifications differ between the proteins associated with ageing and those that are not?

    -   All of the modifications are the same. There isn't a single modification

```{r}
ageing_modifications <- ageing_abundance %>% select(modification) %>% distinct()
nonageing_modifications <- complementary_data %>% select(modification) %>% distinct()
anti_join(ageing_modifications, nonageing_modifications)

```

## Do proteins related to ageing have more oxPTMs than other proteins?

A list of oxPTMs was adapted from [this paper](https://pubs.acs.org/doi/10.1021/cr300073p).

-   One of the common classes of PTMs that are present in ageing proteins are oxPTMs. These PTMs were identified (see Table in the literature study).

```{r}
oxPTMs <- read.table(file = '/Users/anastasialinchik/Desktop/Thesis/Master_thesis/oxPTMs_unimod.txt', header = T)

ageing_abundance$unimod_id <- as.numeric(gsub("\\[|\\].*", "", ageing_abundance$ptm_name))
complementary_data$unimod_id <- as.numeric(gsub("\\[|\\].*", "", complementary_data$ptm_name))

ageing_abundance_oxi <- inner_join(ageing_abundance, oxPTMs, by = join_by(unimod_id == ID))
complementary_data_oxi <- inner_join(complementary_data, oxPTMs, by = join_by(unimod_id == ID))

#normalise
ageing_abundance %>% distinct(LeadProt) %>% dim()
ageing_n <- 1052

complementary_data %>% distinct(LeadProt) %>% dim()
nonageing_n <- 17788

ageing_abundance_oxi_sum <- ageing_abundance_oxi %>% 
  group_by(modification) %>% 
  summarise(mean = mean(total_counts)/1052)

complementary_data_oxi_sum <- complementary_data_oxi %>% 
  group_by(modification) %>% 
  summarise(mean = mean(total_counts)/17788)

ageing_abundance_oxi_sum$group <- 'ageing'
complementary_data_oxi_sum$group <- 'non-ageing'

complete <- rbind(ageing_abundance_oxi_sum, complementary_data_oxi_sum)
```

```{r}
ggplot(complete, aes(x = group, y = mean)) +
  geom_boxplot()
```

```{r}
# Compute t-test
res <- t.test(mean ~ group, data = complete, var.equal = TRUE)
res
```

## Do proteins with a higher disorder score get modified more?

IUPRED REST API was used to get all of the IUPRED scores for all of the proteins. IUPRED outputs a score for each amino acid within a protein. A Python script gets the scores for each amino acid in a protein and then these scores are averaged for each protein and are then taken as the IUPRED score for that protein.

```{r}
iupred_scores <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/iupred_scores.tsv", header = T, sep = '\t')
```

```{r}
uniprot_ids_proteins <- human_ptms %>% select(LeadProt) %>% distinct()
#write.table(uniprot_ids_proteins, file = "/Users/anastasialinchik/Desktop/Thesis/DATA/generated/uniprot_ids_proteins.tsv", quote = F, sep = '\t', row.names = F)
```

Need to calculate the mean number of modifications of each protein in each project.

```{r}
human_ptms_iupred <- inner_join(human_ptms, iupred_scores, by = join_by(LeadProt == UniProt_ID)) 

group1 <- human_ptms_iupred %>% group_by(project_id, LeadProt) %>% summarise(count = sum(total_counts)) %>% select(LeadProt, count) %>% group_by(LeadProt) %>% summarise(mean_occurrence = mean(count))

human_ptms_iupred <- inner_join(group1, iupred_scores, by = join_by(LeadProt == UniProt_ID)) 
```

```{r}
ggplot(human_ptms_iupred, aes(x = Mean_IUPRED_Score, y = mean_occurrence)) +
  geom_point()
```

Now only look at the relevant to ageing.

[IUPred Vignette (bioconductor.org)](https://bioconductor.org/packages/release/bioc/vignettes/idpr/inst/doc/iupred-vignette.html)

```{r}
#| eval: false
#| echo: false
# this uses the R package for IUPRED2. The REST API was used bcs it uses the latest version of IUPRED so more proteins are recognised + it is faster. 
#uniprot_ids <- c('P01023', 'P42684', 'Q9BYF1')

predict_disorder_scores <- function(uniprot_ids) {
  disorder_scores <- c()
  
  for (id in uniprot_ids) {
    disorder_df <- iupred(
      id,
      iupredType = "long",
      plotResults = F,
      proteinName = NA
    )
    
    disorder_score <-
      disorder_df %>% summarise(mean_score = mean(IUPred2))
    disorder_scores <- append(disorder_scores, disorder_score[1, 1])
    
  }
  
  disorder_df <-
    data.frame(uniprot_id = uniprot_ids, disorder_score = disorder_scores)
  
  return(disorder_df)
}

missing_uniprot_ids <- c('A0A024R7F8', 'A0A024R127')
ageing_proteins_ids_disorder <- ageing_proteins_ids %>% filter(! `Uniprot entry` %in% missing_uniprot_ids)

disorder_df <- predict_disorder_scores(ageing_proteins_ids_disorder$`Uniprot entry`)
```

## Post-translational modifications in collagen are proportional to age

Long-lived proteins can be used as estimators of chronological age. Long-lived proteins can be defined in different ways, for example based on the half-life of the protein when compared to the average half-life of proteins in the organism. In this case, long-lived proteins were obtained from the following study: [paper](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3788602/). Proteins were classified as long-lived based on their degree of degradation during the experiment and therefore it was possible to discover new long-lived proteins (no *a priori* assumptions were made).

The study identified a list of long-lived proteins in rats, therefore human orthologs of these proteins were found.

The following approach is tested:

-   Long-lived proteins reside in the cell for longer than most other proteins e.g. collagen in cartilage has a half-life of [117](https://www-sciencedirect-com.kuleuven.e-bronnen.be/science/article/pii/S0021925819558288#:~:text=From%20the%20age%2Drelated%20increases,half%2Dlives%20of%20these%20collagens.). Therefore, these proteins are likely to reside in the body during its complete lifespan.

-   During this time, long-lived proteins are susceptible to PTMs and given their residence time in the body, should accumulate PTMs accordingly.

-   Oxidative damage is known to occur with age.

-   This means that the abundance of oxPTMs in long-lived proteins could be used as an estimator of chronological age.

(It is worth mentioning that there are studies that state that these long-lived proteins are able to reside in the body for an extended period of time because they are resistant to cumulative damage. Could be interesting to look at their stability or other factors that influence this, if indeed no correlations are found.)

-   The number of collage oxPTMs used as the age variable.

-   Now test the abundances of other PTMs.

Analysis:

-   The list of orthologs was taken and identifier of collagen were selected. The following gene names were found: Col6a1, Col6a3, Col4a2 and Col1a1.

-   The mean number of modifications in collagen was determined.

-   The counts were normalised using the raw fiIes that were downloaded from PRIDE (some files cannot be processed by ionbot, therefore some projects are only partially analysed). Also the counts are rescaled to 1-100 (is this even necessary?). The raw files were obtained using the PRIDE API.

```{r}
human_ptms %>% filter(LeadProt == 'P02452') %>% select(project_id) %>% distinct() %>% dim()

human_ptms %>% select(project_id) %>% distinct() %>% dim()
```

```{r}

col_ptms <- human_ptms %>% filter(LeadProt == 'P02452')
  


col_ptms$unimod_id <- as.numeric(gsub("\\[|\\].*", "", col_ptms$ptm_name))

col_ptms_oxi <- inner_join(col_ptms, oxPTMs, by = join_by(unimod_id == ID))

median_col_mod <- col_ptms_oxi %>% group_by(project_id) %>% summarise(median_col_mod = median(total_counts))
```

Does the median number of oxPTMs correlate with the median number of oxPTM modifications of collage COL1A1?

```{r}

human_ptms$unimod_id <- as.numeric(gsub("\\[|\\].*", "", human_ptms$ptm_name))
df <- inner_join(human_ptms, oxPTMs, by = join_by(unimod_id == ID))
df <- df %>% filter(!LeadProt == 'P02452')
df <- df %>% filter(!LeadProt == 'P08123')

mean_mod_count <- df %>% group_by(project_id) %>% summarise(mean_mod_count = mean(total_counts))

df2 <- inner_join(mean_mod_count, median_col_mod, by = join_by(project_id == project_id))
df2 <- df2 %>% filter(median_col_mod < 25)
```

```{r}
ggplot(df2, aes(x = median_col_mod, y = mean_mod_count)) +
  geom_point()

ggplotly()
```

Changes in acetylation

acetylation divide by the total number of modifications

```{r}
df3 <- human_ptms %>% filter(ptm_name == '[1]Acetyl') %>%
  group_by(project_id) %>%
  summarise(mean_acetyl_counts = mean(total_counts))

df3 <- inner_join(df3, median_col_mod, by = join_by(project_id == project_id))
df3 <- df3 %>% filter(median_col_mod < 25)
```

```{r}
ggplot(df3, aes(x = median_col_mod, y = mean_acetyl_counts)) +
  geom_point() +
  geom_smooth(method='lm')

ggplotly()
```

```{r}
model <- lm(mean_acetyl_counts ~ median_col_mod, data = df3)
 
# Perform the significance test
summary(model)
```

```{r}
df3 <- human_ptms %>% filter(ptm_name == '[1]Acetyl') %>%
  group_by(project_id) %>%
  summarise(sum_acetyl_counts = sum(total_counts))

df3 <- inner_join(df3, median_col_mod, by = join_by(project_id == project_id))
df3 <- df3 %>% filter(median_col_mod < 25)
```

```{r}
ggplot(df3, aes(x = median_col_mod, y = sum_acetyl_counts)) +
  geom_point() +
  geom_smooth(method='lm')

ggplotly()
```

```{r}
model <- lm(sum_acetyl_counts ~ median_col_mod, data = df3)
 
# Perform the significance test
summary(model)
```

Trying to normalise the PTM counts

```{r}
sum_ptms <- human_ptms %>% group_by(project_id) %>%
  summarise(sum_ptms = sum(total_counts))

mean_ptms <- human_ptms %>% group_by(project_id) %>%
  summarise(mean_ptms = mean(total_counts))
```

```{r}
df4 <-inner_join(median_col_mod, sum_ptms, by = join_by(project_id == project_id))

df4 <- df4 %>% filter(median_col_mod <25)

ggplot(df4, aes(x = median_col_mod, y = sum_ptms)) +
  geom_point() +
  geom_smooth(method='lm') +
  stat_regline_equation(label.x = 10, label.y = 750000)
```

```{r}
model <- lm(sum_ptms ~ median_col_mod, data = df4)
 
# Perform the significance test
summary(model)
```

```{r}
df5 <-inner_join(median_col_mod, mean_ptms, by = join_by(project_id == project_id))

df5 <- df5 %>% filter(median_col_mod <25)

ggplot(df5, aes(x = median_col_mod, y = mean_ptms)) +
  geom_point()
```

Testing statistical significance

```{r}
model <- lm(mean_ptms ~ median_col_mod, data = df5)
 
# Perform the significance test
summary(model)
```

-   The problem with the above approaches is that if the project had more samples then the number of modifications in that project will also be greater. This is true for when the total abundance is used and when the

-   Changing the normalisation

-   Max value = 100

```{r}
norm <- inner_join(human_ptms, ptms_per_project, by = join_by(project_id == project_id))
norm <- norm %>% mutate(norm_counts = 100*(total_counts.x/total_counts.y))
```

-   We will now look at only the sum of the norm counts.

-   This is for all PTMs together

```{r}
mean_mod_count <- norm %>% group_by(project_id) %>% summarise(mean_norm_count = mean(norm_counts))

df6 <- inner_join(mean_mod_count, median_col_mod, by = join_by(project_id == project_id))
df6 <- df6 %>% filter(median_col_mod < 25)
```

```{r}
ggplot(df6, aes(x = median_col_mod, y = mean_norm_count)) +
  geom_point() +
  geom_smooth(method='lm')

ggplotly()
```

-   Now looking at only the mean number of oxPTMs

```{r}
df7 <- inner_join(norm, oxPTMs, by = join_by(unimod_id == ID)) %>% group_by(project_id) %>%
  summarise(mean_norm_count = mean(norm_counts)) %>% 
  inner_join(median_col_mod, by = join_by(project_id == project_id)) %>%
  filter(median_col_mod < 25)
```

```{r}
ggplot(df7, aes(x = median_col_mod, y = mean_norm_count)) +
  geom_point() +
  geom_smooth(method='lm')

ggplotly()
```

-   Now looking at the sum of all the oxPTMs instead of the mean

```{r}
df8 <- inner_join(norm, oxPTMs, by = join_by(unimod_id == ID)) %>% group_by(project_id) %>%
  summarise(sum_norm_count = sum(norm_counts)) %>% 
  inner_join(median_col_mod, by = join_by(project_id == project_id)) %>%
  filter(median_col_mod < 25)
```

```{r}
ggplot(df8, aes(x = median_col_mod, y = sum_norm_count)) +
  geom_point() +
  geom_smooth(method='lm')

ggplotly()
```

## Chaperones

Chaperones get modified through their life: [Regulation of molecular chaperones through post-translational modifications: Decrypting the chaperone code - PMC (nih.gov)](https://www.ncbi.nlm.nih.gov/pmc/articles/PMC4492711/#:~:text=The%20post%2Dtranslational%20modification%20(PTM)%20of%20molecular%20chaperones%2C,activity%20of%20these%20proteins%20that)

The list of chaperones that are repressed of induced during ageing was obtained [here](https://www.sciencedirect.com/science/article/pii/S2211124714008250?via%3Dihub#app2).

Ideas:

-   Chaperone code

    -   does phosphorylation change in chaperones due to ageing

```{r}

repressed_chaperones <- read_excel(path = '/Users/anastasialinchik/Desktop/Thesis/DATA/subnetwork_chaperones.xlsx', sheet = 'BREHME_TABLE S3D', skip = 19)

repressed_chaperones <- separate_wider_delim(repressed_chaperones, col = 'Label [Family]', names = c("gene_name", "family"), delim = " ")


induced_chaperones <- read_excel(path = '/Users/anastasialinchik/Desktop/Thesis/DATA/subnetwork_chaperones.xlsx', sheet = 'BREHME_TABLE S3E', skip = 19)

induced_chaperones <- separate_wider_delim(induced_chaperones, col = 'Label [Family]', names = c("gene_name", "family"), delim = " ")
```

```{r}
#| include: false
#| eval: false

chaperones <- read.csv(file = "/Users/anastasialinchik/Desktop/Thesis/idmapping_2024_03_17.tsv", sep = '\t', header = T)
```

```{r}
#| eval: false
#| include: false

human_ptms <- human_df %>% filter(ptm_class == 'Post-translational') %>% 
  filter(total_counts >10)

human_ptms_chaperones <- inner_join(human_ptms, chaperones, by = join_by(LeadProt == Entry)) %>%
  group_by(LeadProt) %>%
  summarise(psm_count = mean(total_counts))



ggplot(human_ptms_chaperones, aes(x = LeadProt, psm_count)) +
  geom_bar(stat = 'identity')

human_ptms_chaperones <- human_ptms_chaperones[rep(1:nrow(human_ptms_chaperones), human_ptms_chaperones$total_counts), ]

human_ptms_expanded <- human_ptms[rep(1:nrow(human_ptms), human_ptms$total_counts), ]
human_ptms_expanded <- human_ptms_expanded %>% select(-total_counts)
```

## What modifications are present on the chaperones

```{r}
#| include: false
#| eval: false
chaperone_ptms <- inner_join(human_ptms, chaperones, by = join_by(LeadProt == Entry))

chaperone_ptms_grouped <- chaperone_ptms %>%
  group_by(Uniprot_entry_name) %>%
  summarize(PTMs = paste(unique(ptm_name), collapse = "; "))

table <- kable(chaperone_ptms_grouped, 
      caption = "Summary of PTMs by PTM Residue",
      align = "l",              # Align all columns to the left
      col.names = c("PTM Residue", "Post-translational modification"),  # Specify column names
      format = "html",          # Format the table as HTML
      escape = FALSE,           # Allow HTML formatting
      table.attr = "style='width:50%; margin-left:auto; margin-right:auto;'", # Center the table and set width
      row.names = FALSE,        # Do not display row names
      bold.headers = TRUE      # Make headers bold
)
table

chaperone_ptms_grouped %>%
  kbl() %>%
  kable_styling()
```
